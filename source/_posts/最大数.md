---
title: 最大数
date: 2024-07-23 05:08:07
tags: 线段树
categories: 蓝桥
---

# 解题思路

线段树是一颗完全二叉树。

关于 $seg[N<<2]$：当数组长度为 $N$ 时，线段树的叶节点个数是大于等于 $N$ 的最小的 $2$ 的次方，这意味着叶节点个数 $n$ 需要满足 $\frac{1}{2}~n<N\leq n$，所以 $n$ 的最大值为 $2\times N-1$，而完全二叉树的节点数是 $2\times n-1$，最大值为 $4\times N-3$，所以线段树需要开 $4\times N$ 即 $N<<2$ 的空间。

| $x$            | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| -------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|                | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
| $x<<1$         | 0010 | 0100 | 0110 | 1000 | 1010 | 1100 | 1110 |
|                | 2    | 4    | 6    | 8    | 10   | 12   | 14   |
| $x<<1~\vert~1$ | 0011 | 0101 | 0111 | 1001 | 1010 | 1101 | 1111 |
|                | 3    | 5    | 7    | 9    | 11   | 13   | 15   |

对于每个非叶节点，可以通过上表得到它的两个子节点，构建如下线段树。

| 1      |
| ------ |
| [0, 8) |

| 2      | 3      |
| ------ | ------ |
| [0, 4) | [4, 8) |

| 4      | 5      | 6      | 7      |
| ------ | ------ | ------ | ------ |
| [0, 2) | [2, 4) | [4, 6) | [6, 8) |

| 8      | 9      | 10     | 11     | 12     | 13     | 14     | 15     |
| ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| [0, 1) | [1, 2) | [2, 3) | [3, 4) | [4, 5) | [5, 6) | [6, 7) | [7, 8) |

`modify` 函数用于修改位置 `p` 的值为 `value`。

1. 如果区间长度小于 $2$，说明到了叶节点，直接更新值。
2. 否则，计算中点 `mid`，根据 `p` 的位置决定递归修改左子树或右子树。
3. 修改完毕后，更新当前节点的值为左右子树的最大值。

`query` 函数用于查询区间 $[x,y)$ 内的最大值。

1. 如果查询区间与当前区间没有交集，返回 $0$。
2. 如果当前区间完全包含在查询区间内，返回当前节点的值。
3. 否则，递归查询左右子树的值，并返回其中的最大值。

# AC_Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5 + 10, mod = 1e9 + 7;
int m, d, t;
int seg[N << 2];
void modify(int p, int value, int id = 1, int l = 0, int r = N) {
    if (r - l < 2) {
        seg[id] = value;
        return;
    }
    int mid = (l + r) >> 1;
    if (p < mid) {
        modify(p, value, id << 1, l, mid);
    } else {
        modify(p, value, id << 1 | 1, mid, r);
    }
    seg[id] = max(seg[id << 1], seg[id << 1 | 1]);
}
int query(int x, int y, int id = 1, int l = 0, int r = N) {
    if (y <= l || r <= x) {
        return 0;
    }
    if (x <= l && r <= y) {
        return seg[id];
    }
    int mid = (l + r) >> 1;
    return max(query(x, y, id << 1, l, mid), query(x, y, id << 1 | 1, mid, r));
}
void solve() {
    cin >> m >> d;
    int cnt = 0;
    while (m--) {
        char op; cin >> op;
        if (op == 'Q') {
            int l; cin >> l;
            t = query(cnt - l, cnt);
            cout << t << '\n';
        } else {
            int n; cin >> n;
            n = (n + t) % d;
            modify(cnt, n);
            cnt++;
        }
    }
}
signed main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    solve();
    return 0;
}
```
