---
title: 小蓝的鸡蛋
date: 2024-07-23 13:14:56
tags: [树状数组, 线段树]
categories: [蓝桥]
---

# 解题思路

## 一、树状数组

### 低位计算     

|             | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ----------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $x$         | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 |
| $\sim x$    | 1110 | 1101 | 1100 | 1011 | 1010 | 1001 | 1000 | 0111 |
| $-~x$       | 1111 | 1110 | 1101 | 1100 | 1011 | 1010 | 1001 | 1000 |
| $x~\&-x$    | 0001 | 0010 | 0001 | 0100 | 0001 | 0010 | 0001 | 1000 |
| $lowbit(x)$ | 1    | 2    | 1    | 4    | 1    | 2    | 1    | 8    |

`lowbit` 函数用于获取 $x$ 的最低位的 $1$，等价于 $x$ 和 $-~x$ 的按位与操作。

|     | 1     | 2     | 3     | 4     | 5     | 6     | 7     | 8   |
| --- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | --- |
| $1$ | 1     |       |       |       |       |       |       |     |
| $2$ | 1 + 1 | 2     |       |       |       |       |       |     |
| $3$ |       |       | 3     |       |       |       |       |     |
| $4$ | 2 + 2 | 2 + 2 | 3 + 1 | 4     |       |       |       |     |
| $5$ |       |       |       |       | 5     |       |       |     |
| $6$ |       |       |       |       | 5 + 1 | 6     |       |     |
| $7$ |       |       |       |       |       |       | 7     |     |
| $8$ | 4 + 4 | 4 + 4 | 4 + 4 | 4 + 4 | 6 + 2 | 6 + 2 | 7 + 1 | 8   |

对于每个 $x$，不断加上 $lowbit(x)$，直到超出范围。这样就能从上表中得到每个 $tree[i]$ 管辖的 $a[i]$ 的范围。

| $tree[i]$ | 1   | 2     | 3   | 4     | 5   | 6     | 7   | 8     |
| --------- | --- | ----- | --- | ----- | --- | ----- | --- | ----- |
| $a[i]$    | 1   | 1 ~ 2 | 3   | 1 ~ 4 | 5   | 5 ~ 6 | 7   | 1 ~ 8 |

### 更新操作     

|           | 1   | 2   | 3   | 4   | 5   |
| --------- | --- | --- | --- | --- | --- |
| $a[1]+1$  | +1  | +1  |     | +1  |     |
| $a[2]+1$  |     | +1  |     | +1  |     |
| $a[3]+1$  |     |     | +1  | +1  |     |
| $a[4]+1$  |     |     |     | +1  |     |
| $a[5]+1$  |     |     |     |     | +1  |
| $a[2]+2$  |     | +2  |     | +2  |     |
| $tree[i]$ | 1   | 4   | 1   | 6   | 1   |

`update` 函数用于将 `val` 加到第 `i` 个位置，并更新相关的节点。循环保证了所有受影响的节点都被更新。

|          | 1   | 2   | 3   | 4   | 5   |
| -------- | --- | --- | --- | --- | --- |
| $a[1]+1$ | +1  |     |     |     |     |
| $a[2]+1$ |     | +1  |     |     |     |
| $a[3]+1$ |     |     | +1  |     |     |
| $a[4]+1$ |     |     |     | +1  |     |
| $a[5]+1$ |     |     |     |     | +1  |
| $a[2]+2$ |     | +2  |     |     |     |
| $a[i]$   | 1   | 3   | 1   | 1   | 1   |

对应的 $a[i]$ 数组如上表，可以发现两表是对应的。

### 查询操作

|     | 1   | 2     | 3   | 4     | 5   | 6     | 7   | 8   |
| --- | --- | ----- | --- | ----- | --- | ----- | --- | --- |
| $1$ | 1   |       |     |       |     |       |     |     |
| $2$ |     | 2     |     |       |     |       |     |     |
| $3$ |     | 3 - 1 | 3   |       |     |       |     |     |
| $4$ |     |       |     | 4     |     |       |     |     |
| $5$ |     |       |     | 5 - 1 | 5   |       |     |     |
| $6$ |     |       |     | 6 - 2 |     | 6     |     |     |
| $7$ |     |       |     | 6 - 2 |     | 7 - 1 | 7   |     |
| $8$ |     |       |     |       |     |       |     | 8   |

`query` 函数用于计算从位置 $1$ 到位置 $i$ 的前缀和。通过不断减去 $lowbit(i)$ 来遍历相关的节点。得到每次查询的结果是 `tree` 数组中哪几个元素之和。

| $query(x)$ | 1   | 2   | 3     | 4   | 5     | 6     | 7         | 8   |
| ---------- | --- | --- | ----- | --- | ----- | ----- | --------- | --- |
| $tree[i]$  | 1   | 2   | 2 + 3 | 4   | 4 + 5 | 4 + 6 | 4 + 6 + 7 | 8   |

通过 `query(r) - query(l - 1)` 来查询 $[l,r]$ 的区间和。

| $l,r$                 | 1, 2                    | 3, 3                             |
| --------------------- | ----------------------- | -------------------------------- |
| $query(r)-query(l-1)$ | query(2) - query(1 - 1) | query(3) - query(3 - 1)          |
|                       | query(2) - query(0)     | query(3) - query(2)              |
|                       | tree[2] - tree[0]       | (tree[2] + tree[3])- tree[2]     |
|                       | 4 - 0                   | (4 + 1) - 4                      |
|                       | 4                       | 1                                |

## 二、线段树

略

# AC_Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2e5 + 10;
//树状数组
vector<int> tree(N, 0);
int lowbit(int x) {
    return x & (-x);
}
void update(int i, int val) {
    while (i < N) {
        tree[i] += val;
        i += lowbit(i);
    }
}
int query(int i) {
    int sum = 0;
    while (i > 0) {
        sum += tree[i];
        i -= lowbit(i);
    }
    return sum;
}
void solve() {
    int n; cin >> n;
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        update(i, x);
    }
    int q; cin >> q;
    while (q--) {
        int op; cin >> op;
        if (op == 1) {
            int i, x; cin >> i >> x;
            update(i, x);
        } else {
            int l, r; cin >> l >> r;
            cout << query(r) - query(l - 1) << '\n';
        }
    }
}
//线段树
int seg[N << 2];
void add(int p, int value, int id = 1, int l = 0, int r = N) {
    if (r - l < 2) {
        seg[id] += value;
        return;
    }
    int mid = l + r >> 1;
    if (p < mid) {
        add(p, value, id << 1, l, mid);
    } else {
        add(p, value, id << 1 | 1, mid, r);
    }
    seg[id] = seg[id << 1] + seg[id << 1 | 1];
}
int query(int x, int y, int id = 1, int l = 0, int r = N) {
    if (r <= x || y <= l) {
        return 0;
    }
    if (x <= l && r <= y) {
        return seg[id];
    }
    int mid = l + r >> 1;
    return query(x, y, id << 1, l, mid) + query(x, y, id << 1 | 1, mid, r);
}
void solve() {
    int n; cin >> n;
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        add(i, x);
    }
    int q; cin >> q;
    while (q--) {
        int op; cin >> op;
        if (op == 1) {
            int i, x; cin >> i >> x;
            add(i, x);
        } else {
            int l, r; cin >> l >> r;
            cout << query(l, r + 1) << '\n';
        }
    }
}
signed main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    solve();
    return 0;
}
```