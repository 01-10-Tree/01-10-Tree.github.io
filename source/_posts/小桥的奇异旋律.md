---
title: 小桥的奇异旋律
date: 2024-07-30 22:12:37
tags: [前缀和, 贪心]
categories: 蓝桥
---

# 解题思路

## 分析题意

题目要求对于一个长度为 $N$ 的音符序列 $a$，满足两个条件：

* 在弹奏每一个音符时，从第一个音符到当前音符的音高总和不能为零；
* 相邻两个音符的音高总和之间，必须改变符号。

假设数组 $s$ 为 $a$ 的前缀和数组，$s_i$ ​表示 $a$ 中前 $i$ 个音符的音高和，我们题目的两个要求转化一下：

*   对于 $i\in[1,n]$，$s_i$ 不能为 $0$。
*   对于 $i\in[2,n]$，$s_i\times s_{i−1}<0$，也就是 $s_i$ 和 $s_{i−1}$ 异号。

## 做法分析

假设 $s_1$ 是正数，那么 $s_2$ 必须为负数，继而 $s_3$ 必须为正数 $\cdots$，后面每个数的正负性均确定。

假设 $s_1$ 是负数，那么 $s_2$ 必须为正数，继而 $s_3$ 必须为负数 $\cdots$，后面每个数的正负性均确定。

不难发现，题目可能出现的情况只有上面两种，我们只需要枚举一下 $s_1$ 是正数和负数的情况，然后判断后面每个数转换为其对应正负性需要的操作次数之和，两种情况取较小值作为答案。

对于每个数 $s_i$ 我们都有以下贪心决策：

* 若 $s_i$ 为正数：
    * 我们需要将其变为负数，为了节省操作次数，我们将其变为 $−1$ 即可，并计算出对应操作次数。
    * 若需要变为正数，已符合条件，不做处理。
* 若 $s_i$ 为负数：
    * 我们需要将其变为正数，为了节省操作次数，我们将其变为 $1$ 即可，并计算出对应操作次数。
    * 若需要变为负数，已符合条件，不做处理。

需要注意的是，当我们对第 $i$ 个数进行操作时，因为 $s$ 是前缀和数组，会导致 $s_j(j\in[i+1,n])$ 的数进行同样的加减，我们可以使用一个变量 `res` 来记录前面的数的操作的变化量。这样在考虑任意 $s_i$ 时，需要先加上当前的变化量，此时才是 $s_i$ 真正意义上的值。当然上面这个操作本质上是一个单点修改、区间查询的操作，我们也可以使用树状数组和线段树来维护。

时间复杂度：$O(n)$。

# AC_Code


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
//using ll = long long;
const int N = 2e5 + 10, mod = 1e9 + 7;
void solve() {
    int n; cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        a[i] += a[i - 1];
    }
    int ans = 1e18, res = 0, sum = 0;
    for (int i = 1; i <= n; i++) {
        if (i & 1) {
            int v = a[i] + res;
            if (v <= 0) {
                res += 1 - v;
                sum += 1 - v;
            }
        } else {
            int v = a[i] + res;
            if (v >= 0) {
                res -= v + 1;
                sum += v + 1;
            }
        }
    }
    ans = min(ans, sum);
    sum = 0;
    res = 0;
    for (int i = 1; i <= n; i++) {
        if (i & 1) {
            int v = a[i] + res;
            if (v >= 0) {
                res -= v + 1;
                sum += v + 1;
            }
        } else {
            int v = a[i] + res;
            if (v <= 0) {
                res += 1 - v;
                sum += 1 - v;
            }
        }
    }
    ans = min(ans, sum);
    cout << ans;
}
signed main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    //int _; cin >> _; while (_--)
    solve();
    return 0;
}
```